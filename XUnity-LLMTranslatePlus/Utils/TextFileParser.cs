using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using XUnity_LLMTranslatePlus.Models;

namespace XUnity_LLMTranslatePlus.Utils
{
    /// <summary>
    /// 文本文件解析器（用于解析 XUnity _AutoGeneratedTranslations.txt 文件）
    /// </summary>
    public class TextFileParser
    {
        private Dictionary<string, string> _translations = new Dictionary<string, string>();
        private List<string> _fileLines = new List<string>();
        private readonly object _lockObject = new object();

        /// <summary>
        /// 检测转义字符是否损坏（value 缺少 key 中的转义字符）
        /// </summary>
        private static bool IsCorruptedTranslation(string key, string value)
        {
            // 如果完全相同，肯定未翻译
            if (string.Equals(key, value, StringComparison.Ordinal))
                return false;
            
            // 检查 key 中的转义字符数量
            int keyEscapeCount = CountEscapeChars(key);
            int valueEscapeCount = CountEscapeChars(value);
            
            // 如果 value 缺少转义字符，可能是损坏的
            if (keyEscapeCount > 0 && valueEscapeCount < keyEscapeCount)
                return true;
            
            return false;
        }

        /// <summary>
        /// 统计文本中的转义字符数量
        /// </summary>
        private static int CountEscapeChars(string text)
        {
            if (string.IsNullOrEmpty(text))
                return 0;
            
            int count = 0;
            count += Regex.Matches(text, @"\\n").Count;
            count += Regex.Matches(text, @"\\r").Count;
            count += Regex.Matches(text, @"\\t").Count;
            return count;
        }

        // 注意：以下方法已弃用，不适用于 XUnity 文件格式
        // XUnity 文件直接存储字面字符（如 \n 是两个字符：反斜杠+n）
        // 不需要转义/反转义处理，直接按原样读写即可
        
        /*
        /// <summary>
        /// 转义特殊字符（用于保存文件时）
        /// 警告：此方法不适用于 XUnity 文件格式！
        /// </summary>
        private static string EscapeValue(string value)
        {
            if (string.IsNullOrEmpty(value))
                return value;

            return value
                .Replace("\\", "\\\\")  // 反斜杠必须最先处理
                .Replace("\n", "\\n")   // 实际换行符转为字面 \n
                .Replace("\r", "\\r")   // 实际回车符转为字面 \r
                .Replace("\t", "\\t")   // 实际制表符转为字面 \t
                .Replace("\"", "\\\""); // 双引号转义
        }

        /// <summary>
        /// 反转义特殊字符（用于读取文件时）
        /// 警告：此方法不适用于 XUnity 文件格式！
        /// </summary>
        private static string UnescapeValue(string value)
        {
            if (string.IsNullOrEmpty(value))
                return value;

            // 处理转义序列，注意顺序很重要
            var result = value;
            
            // 先处理双字符转义序列
            result = result.Replace("\\n", "\n");   // 字面 \n 转为实际换行符
            result = result.Replace("\\r", "\r");   // 字面 \r 转为实际回车符
            result = result.Replace("\\t", "\t");   // 字面 \t 转为实际制表符
            result = result.Replace("\\\"", "\"");  // 转义的引号
            result = result.Replace("\\\\", "\\");  // 转义的反斜杠必须最后处理

            return result;
        }
        */

        /// <summary>
        /// 解析文件
        /// </summary>
        public async Task<List<TranslationEntry>> ParseFileAsync(string filePath)
        {
            var entries = new List<TranslationEntry>();

            if (!File.Exists(filePath))
            {
                throw new FileNotFoundException($"文件不存在: {filePath}");
            }

            try
            {
                var lines = await File.ReadAllLinesAsync(filePath, Encoding.UTF8);
                
                lock (_lockObject)
                {
                    _fileLines = lines.ToList();
                    _translations.Clear();
                }

                foreach (var line in lines)
                {
                    // 跳过空行和注释
                    if (string.IsNullOrWhiteSpace(line) || line.TrimStart().StartsWith("//"))
                    {
                        continue;
                    }

                    // 解析键值对（格式：key=value）
                    int separatorIndex = line.IndexOf('=');
                    if (separatorIndex > 0)
                    {
                        string key = line.Substring(0, separatorIndex).Trim();
                        string value = line.Substring(separatorIndex + 1).Trim();

                        // 移除可能的引号
                        if (value.StartsWith("\"") && value.EndsWith("\""))
                        {
                            value = value.Substring(1, value.Length - 2);
                        }

                        var entry = new TranslationEntry
                        {
                            Key = key,
                            Value = value,
                            IsTranslated = !string.Equals(key, value, StringComparison.Ordinal) 
                                           && !IsCorruptedTranslation(key, value),
                            HasError = false
                        };

                        entries.Add(entry);

                        lock (_lockObject)
                        {
                            _translations[key] = value;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                throw new Exception($"解析文件失败: {ex.Message}", ex);
            }

            return entries;
        }

        /// <summary>
        /// 获取未翻译的条目
        /// </summary>
        public List<TranslationEntry> GetUntranslatedEntries(List<TranslationEntry> entries)
        {
            return entries.Where(e => !e.IsTranslated).ToList();
        }

        /// <summary>
        /// 更新翻译
        /// </summary>
        public void UpdateTranslation(string key, string value)
        {
            lock (_lockObject)
            {
                _translations[key] = value;
            }
        }

        /// <summary>
        /// 批量更新翻译
        /// </summary>
        public void UpdateTranslations(Dictionary<string, string> translations)
        {
            lock (_lockObject)
            {
                foreach (var kvp in translations)
                {
                    _translations[kvp.Key] = kvp.Value;
                }
            }
        }

        /// <summary>
        /// 保存文件
        /// </summary>
        public async Task SaveFileAsync(string filePath)
        {
            try
            {
                var outputLines = new List<string>();

                lock (_lockObject)
                {
                    foreach (var line in _fileLines)
                    {
                        // 保留空行和注释
                        if (string.IsNullOrWhiteSpace(line) || line.TrimStart().StartsWith("//"))
                        {
                            outputLines.Add(line);
                            continue;
                        }

                        // 查找键值对
                        int separatorIndex = line.IndexOf('=');
                        if (separatorIndex > 0)
                        {
                            string key = line.Substring(0, separatorIndex).Trim();

                            // 如果有更新的翻译，使用新的值
                            if (_translations.ContainsKey(key))
                            {
                                string newValue = _translations[key];
                                
                                // 保持原始格式（是否有引号）
                                bool hasQuotes = line.Contains("\"");
                                string newLine = hasQuotes
                                    ? $"{key}=\"{newValue}\""
                                    : $"{key}={newValue}";
                                
                                outputLines.Add(newLine);
                            }
                            else
                            {
                                // 没有更新，保持原样
                                outputLines.Add(line);
                            }
                        }
                        else
                        {
                            // 不是键值对，保持原样
                            outputLines.Add(line);
                        }
                    }
                }

                await File.WriteAllLinesAsync(filePath, outputLines, Encoding.UTF8);
            }
            catch (Exception ex)
            {
                throw new Exception($"保存文件失败: {ex.Message}", ex);
            }
        }

        /// <summary>
        /// 获取文件统计信息
        /// </summary>
        public FileStatistics GetStatistics()
        {
            lock (_lockObject)
            {
                int total = _translations.Count;
                int translated = _translations.Count(kvp => !string.Equals(kvp.Key, kvp.Value, StringComparison.Ordinal));
                int untranslated = total - translated;

                return new FileStatistics
                {
                    TotalEntries = total,
                    TranslatedEntries = translated,
                    UntranslatedEntries = untranslated,
                    TranslationRate = total > 0 ? (double)translated / total * 100 : 0
                };
            }
        }

        /// <summary>
        /// 获取所有翻译条目
        /// </summary>
        public Dictionary<string, string> GetAllTranslations()
        {
            lock (_lockObject)
            {
                return new Dictionary<string, string>(_translations);
            }
        }

        /// <summary>
        /// 清空缓存
        /// </summary>
        public void Clear()
        {
            lock (_lockObject)
            {
                _translations.Clear();
                _fileLines.Clear();
            }
        }
    }

    /// <summary>
    /// 文件统计信息
    /// </summary>
    public class FileStatistics
    {
        public int TotalEntries { get; set; }
        public int TranslatedEntries { get; set; }
        public int UntranslatedEntries { get; set; }
        public double TranslationRate { get; set; }
    }
}

