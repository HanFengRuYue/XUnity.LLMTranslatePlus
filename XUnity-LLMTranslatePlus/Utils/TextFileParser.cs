using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading;
using System.Threading.Tasks;
using XUnity_LLMTranslatePlus.Exceptions;
using XUnity_LLMTranslatePlus.Models;

namespace XUnity_LLMTranslatePlus.Utils
{
    /// <summary>
    /// 文本文件解析器（用于解析 XUnity _AutoGeneratedTranslations.txt 文件）
    /// </summary>
    public class TextFileParser
    {
        private Dictionary<string, string> _translations = new Dictionary<string, string>();
        private List<string> _fileLines = new List<string>();
        private readonly object _lockObject = new object();

        /// <summary>
        /// 检测转义字符是否损坏（value 缺少 key 中的转义字符）
        /// </summary>
        private static bool IsCorruptedTranslation(string key, string value)
        {
            // 如果完全相同，肯定未翻译
            if (string.Equals(key, value, StringComparison.Ordinal))
                return false;
            
            // 检查 key 中的转义字符数量
            int keyEscapeCount = CountEscapeChars(key);
            int valueEscapeCount = CountEscapeChars(value);
            
            // 如果 value 缺少转义字符，可能是损坏的
            if (keyEscapeCount > 0 && valueEscapeCount < keyEscapeCount)
                return true;
            
            return false;
        }

        /// <summary>
        /// 统计文本中的转义字符数量
        /// </summary>
        private static int CountEscapeChars(string text)
        {
            if (string.IsNullOrEmpty(text))
                return 0;
            
            int count = 0;
            count += Regex.Matches(text, @"\\n").Count;
            count += Regex.Matches(text, @"\\r").Count;
            count += Regex.Matches(text, @"\\t").Count;
            return count;
        }

        // 注意：以下方法已弃用，不适用于 XUnity 文件格式
        // XUnity 文件直接存储字面字符（如 \n 是两个字符：反斜杠+n）
        // 不需要转义/反转义处理，直接按原样读写即可
        
        /*
        /// <summary>
        /// 转义特殊字符（用于保存文件时）
        /// 警告：此方法不适用于 XUnity 文件格式！
        /// </summary>
        private static string EscapeValue(string value)
        {
            if (string.IsNullOrEmpty(value))
                return value;

            return value
                .Replace("\\", "\\\\")  // 反斜杠必须最先处理
                .Replace("\n", "\\n")   // 实际换行符转为字面 \n
                .Replace("\r", "\\r")   // 实际回车符转为字面 \r
                .Replace("\t", "\\t")   // 实际制表符转为字面 \t
                .Replace("\"", "\\\""); // 双引号转义
        }

        /// <summary>
        /// 反转义特殊字符（用于读取文件时）
        /// 警告：此方法不适用于 XUnity 文件格式！
        /// </summary>
        private static string UnescapeValue(string value)
        {
            if (string.IsNullOrEmpty(value))
                return value;

            // 处理转义序列，注意顺序很重要
            var result = value;
            
            // 先处理双字符转义序列
            result = result.Replace("\\n", "\n");   // 字面 \n 转为实际换行符
            result = result.Replace("\\r", "\r");   // 字面 \r 转为实际回车符
            result = result.Replace("\\t", "\t");   // 字面 \t 转为实际制表符
            result = result.Replace("\\\"", "\"");  // 转义的引号
            result = result.Replace("\\\\", "\\");  // 转义的反斜杠必须最后处理

            return result;
        }
        */

        /// <summary>
        /// 解析文件（带重试机制，使用 FileShare.ReadWrite 避免锁定文件）
        /// </summary>
        public async Task<List<TranslationEntry>> ParseFileAsync(string filePath, CancellationToken cancellationToken = default)
        {
            var entries = new List<TranslationEntry>();

            // 验证文件路径
            PathValidator.ValidateFileExists(filePath);
            string validatedPath = PathValidator.ValidateAndNormalizePath(filePath);

            const int maxRetries = 5;
            int retryCount = 0;
            Random random = new Random();

            while (retryCount < maxRetries)
            {
                try
                {
                    List<string> lines;

                    // 使用 FileStream 明确指定 FileShare.ReadWrite，避免阻止 XUnity 写入
                    await using (var fileStream = new FileStream(
                        validatedPath,
                        FileMode.Open,
                        FileAccess.Read,
                        FileShare.ReadWrite,  // 关键：允许其他进程同时读写
                        4096,
                        FileOptions.Asynchronous))
                    {
                        using var reader = new StreamReader(fileStream, Encoding.UTF8);
                        lines = new List<string>();
                        string? line;
                        while ((line = await reader.ReadLineAsync()) != null)
                        {
                            cancellationToken.ThrowIfCancellationRequested();
                            lines.Add(line);
                        }
                    }

                    // 读取成功，处理数据
                    lock (_lockObject)
                    {
                        _fileLines = lines;
                        _translations.Clear();
                    }

                    foreach (var line in lines)
                    {
                        // 跳过空行和注释
                        if (string.IsNullOrWhiteSpace(line) || line.TrimStart().StartsWith("//"))
                        {
                            continue;
                        }

                        // 解析键值对（格式：key=value）
                        int separatorIndex = line.IndexOf('=');
                        if (separatorIndex > 0)
                        {
                            // 使用 Span<char> 优化字符串操作，减少内存分配
                            ReadOnlySpan<char> lineSpan = line.AsSpan();
                            ReadOnlySpan<char> keySpan = lineSpan.Slice(0, separatorIndex).Trim();
                            ReadOnlySpan<char> valueSpan = lineSpan.Slice(separatorIndex + 1).Trim();

                            // 移除可能的引号（key 和 value 都需要处理）
                            if (keySpan.Length >= 2 && keySpan[0] == '"' && keySpan[^1] == '"')
                            {
                                keySpan = keySpan.Slice(1, keySpan.Length - 2);
                            }

                            if (valueSpan.Length >= 2 && valueSpan[0] == '"' && valueSpan[^1] == '"')
                            {
                                valueSpan = valueSpan.Slice(1, valueSpan.Length - 2);
                            }

                            string key = keySpan.ToString();
                            string value = valueSpan.ToString();

                            var entry = new TranslationEntry
                            {
                                Key = key,
                                Value = value,
                                IsTranslated = !string.Equals(key, value, StringComparison.Ordinal)
                                               && !IsCorruptedTranslation(key, value),
                                HasError = false
                            };

                            entries.Add(entry);

                            lock (_lockObject)
                            {
                                _translations[key] = value;
                            }
                        }
                    }

                    // 成功解析，退出重试循环
                    return entries;
                }
                catch (IOException) when (retryCount < maxRetries - 1)
                {
                    // 文件被占用，等待后重试
                    retryCount++;
                    int delayMs = random.Next(100, 500); // 随机延迟 100-500ms
                    await Task.Delay(delayMs, cancellationToken);
                }
                catch (Exception ex)
                {
                    throw new FileOperationException(
                        $"解析文件失败: {ex.Message}",
                        ex,
                        filePath,
                        "Parse");
                }
            }

            // 重试次数用尽
            throw new FileOperationException(
                $"解析文件失败: 文件被占用，已重试 {maxRetries} 次",
                filePath,
                "Parse");
        }

        /// <summary>
        /// 获取未翻译的条目
        /// </summary>
        public List<TranslationEntry> GetUntranslatedEntries(List<TranslationEntry> entries)
        {
            return entries.Where(e => !e.IsTranslated).ToList();
        }

        /// <summary>
        /// 更新翻译
        /// </summary>
        public void UpdateTranslation(string key, string value)
        {
            lock (_lockObject)
            {
                _translations[key] = value;
            }
        }

        /// <summary>
        /// 批量更新翻译
        /// </summary>
        public void UpdateTranslations(Dictionary<string, string> translations)
        {
            lock (_lockObject)
            {
                foreach (var kvp in translations)
                {
                    _translations[kvp.Key] = kvp.Value;
                }
            }
        }

        /// <summary>
        /// 保存文件（带重试机制，防止文件冲突）
        /// </summary>
        public async Task SaveFileAsync(string filePath, CancellationToken cancellationToken = default)
        {
            // 验证文件路径
            string validatedPath = PathValidator.ValidateAndNormalizePath(filePath);

            const int maxRetries = 5;
            int retryCount = 0;
            Random random = new Random();

            while (retryCount < maxRetries)
            {
                try
                {
                    var outputLines = new List<string>();

                    lock (_lockObject)
                    {
                        foreach (var line in _fileLines)
                        {
                            // 保留空行和注释
                            if (string.IsNullOrWhiteSpace(line) || line.TrimStart().StartsWith("//"))
                            {
                                outputLines.Add(line);
                                continue;
                            }

                            // 查找键值对
                            int separatorIndex = line.IndexOf('=');
                            if (separatorIndex > 0)
                            {
                                // 使用 Span<char> 优化
                                ReadOnlySpan<char> lineSpan = line.AsSpan();
                                ReadOnlySpan<char> keySpan = lineSpan.Slice(0, separatorIndex).Trim();

                                // 检测原始行是否使用引号格式
                                bool keyHasQuotes = keySpan.Length >= 2 && keySpan[0] == '"' && keySpan[^1] == '"';

                                // 移除引号以匹配存储的 key
                                if (keyHasQuotes)
                                {
                                    keySpan = keySpan.Slice(1, keySpan.Length - 2);
                                }

                                string key = keySpan.ToString();

                                // 如果有更新的翻译，使用新的值
                                if (_translations.TryGetValue(key, out string? newValue))
                                {
                                    // 保持原始格式（是否有引号）
                                    string newLine = keyHasQuotes
                                        ? $"\"{key}\"=\"{newValue}\""
                                        : $"{key}={newValue}";

                                    outputLines.Add(newLine);
                                }
                                else
                                {
                                    // 没有更新，保持原样
                                    outputLines.Add(line);
                                }
                            }
                            else
                            {
                                // 不是键值对，保持原样
                                outputLines.Add(line);
                            }
                        }
                    }

                    // 使用 FileShare.Read 允许其他进程同时读取
                    await using (var fileStream = new FileStream(
                        validatedPath,
                        FileMode.Create,
                        FileAccess.Write,
                        FileShare.Read,
                        4096,
                        FileOptions.Asynchronous))
                    {
                        await using (var writer = new StreamWriter(fileStream, Encoding.UTF8))
                        {
                            foreach (var line in outputLines)
                            {
                                await writer.WriteLineAsync(line);
                            }
                        }
                    }

                    // 写入成功，退出重试循环
                    return;
                }
                catch (IOException) when (retryCount < maxRetries - 1)
                {
                    // 文件被占用，等待后重试
                    retryCount++;
                    int delayMs = random.Next(200, 1000); // 随机延迟 200-1000ms
                    await Task.Delay(delayMs, cancellationToken);
                }
                catch (Exception ex)
                {
                    throw new FileOperationException(
                        $"保存文件失败: {ex.Message}",
                        ex,
                        filePath,
                        "Save");
                }
            }

            // 重试次数用尽
            throw new FileOperationException(
                $"保存文件失败: 文件被占用，已重试 {maxRetries} 次",
                filePath,
                "Save");
        }

        /// <summary>
        /// 获取文件统计信息
        /// </summary>
        public FileStatistics GetStatistics()
        {
            lock (_lockObject)
            {
                int total = _translations.Count;
                int translated = _translations.Count(kvp => !string.Equals(kvp.Key, kvp.Value, StringComparison.Ordinal));
                int untranslated = total - translated;

                return new FileStatistics
                {
                    TotalEntries = total,
                    TranslatedEntries = translated,
                    UntranslatedEntries = untranslated,
                    TranslationRate = total > 0 ? (double)translated / total * 100 : 0
                };
            }
        }

        /// <summary>
        /// 获取所有翻译条目
        /// </summary>
        public Dictionary<string, string> GetAllTranslations()
        {
            lock (_lockObject)
            {
                return new Dictionary<string, string>(_translations);
            }
        }

        /// <summary>
        /// 清空缓存
        /// </summary>
        public void Clear()
        {
            lock (_lockObject)
            {
                _translations.Clear();
                _fileLines.Clear();
            }
        }
    }

    /// <summary>
    /// 文件统计信息
    /// </summary>
    public class FileStatistics
    {
        public int TotalEntries { get; set; }
        public int TranslatedEntries { get; set; }
        public int UntranslatedEntries { get; set; }
        public double TranslationRate { get; set; }
    }
}

