using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using XUnity_LLMTranslatePlus.Models;
using XUnity_LLMTranslatePlus.Utils;

namespace XUnity_LLMTranslatePlus.Services
{
    /// <summary>
    /// 文本编辑服务
    /// </summary>
    public class TextEditorService
    {
        private readonly LogService _logService;
        private readonly ConfigService _configService;
        private TextFileParser? _parser;
        private string? _currentFilePath;
        private List<TranslationEntry> _entries = new List<TranslationEntry>();
        private readonly object _lockObject = new object();

        public event EventHandler<string>? FileLoaded;
        public event EventHandler? EntriesUpdated;

        public TextEditorService(LogService logService, ConfigService configService)
        {
            _logService = logService;
            _configService = configService;
        }

        /// <summary>
        /// 加载文件
        /// </summary>
        public async Task<List<TranslationEntry>> LoadFileAsync(string filePath)
        {
            // 验证文件路径
            PathValidator.ValidateFileExists(filePath);
            string validatedPath = PathValidator.ValidateAndNormalizePath(filePath);

            try
            {
                await _logService.LogAsync($"正在加载文件: {validatedPath}", LogLevel.Info);

                _parser = new TextFileParser();
                var entries = await _parser.ParseFileAsync(validatedPath);

                lock (_lockObject)
                {
                    _currentFilePath = validatedPath;
                    _entries = entries;
                }

                await _logService.LogAsync($"文件加载成功，共 {entries.Count} 条记录", LogLevel.Info);

                FileLoaded?.Invoke(this, filePath);

                return entries;
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"加载文件失败: {ex.Message}", LogLevel.Error);
                throw new Exception($"加载文件失败: {ex.Message}", ex);
            }
        }

        /// <summary>
        /// 自动查找并加载翻译文件
        /// </summary>
        public async Task<List<TranslationEntry>> LoadFromGameDirectoryAsync(string gameDirectory)
        {
            // 验证游戏目录路径
            PathValidator.ValidateDirectoryExists(gameDirectory);
            string validatedGameDir = PathValidator.ValidateAndNormalizePath(gameDirectory);

            string? filePath = FindTranslationFile(validatedGameDir);

            if (filePath == null)
            {
                throw new Exception($"在游戏目录中未找到 _AutoGeneratedTranslations.txt 文件: {gameDirectory}");
            }

            return await LoadFileAsync(filePath);
        }

        /// <summary>
        /// 从配置加载翻译文件（优先使用手动指定路径，否则自动检测）
        /// </summary>
        public async Task<List<TranslationEntry>> LoadFromConfigAsync(AppConfig config)
        {
            string? filePath = null;

            // 优先使用手动指定的文件路径
            if (!string.IsNullOrWhiteSpace(config.ManualTranslationFilePath))
            {
                if (File.Exists(config.ManualTranslationFilePath))
                {
                    filePath = config.ManualTranslationFilePath;
                    await _logService.LogAsync($"使用手动指定的翻译文件: {filePath}", LogLevel.Info);
                }
                else
                {
                    await _logService.LogAsync($"手动指定的文件不存在，尝试自动检测: {config.ManualTranslationFilePath}", LogLevel.Warning);
                }
            }

            // 如果没有手动路径或手动路径无效，使用自动检测
            if (filePath == null && !string.IsNullOrWhiteSpace(config.GameDirectory))
            {
                // 验证游戏目录路径
                PathValidator.ValidateDirectoryExists(config.GameDirectory);
                string validatedGameDir = PathValidator.ValidateAndNormalizePath(config.GameDirectory);

                // 查找翻译文件
                filePath = FindTranslationFile(validatedGameDir);

                if (filePath != null)
                {
                    await _logService.LogAsync($"自动检测到翻译文件: {filePath}", LogLevel.Info);
                }
            }

            if (filePath == null)
            {
                throw new Exception("未找到翻译文件。请在翻译设置中配置游戏目录或手动指定翻译文件。");
            }

            return await LoadFileAsync(filePath);
        }

        /// <summary>
        /// 查找翻译文件
        /// </summary>
        private string? FindTranslationFile(string gameDirectory)
        {
            string bepInExPath = Path.Combine(gameDirectory, "BepInEx", "Translation");

            if (!Directory.Exists(bepInExPath))
            {
                return null;
            }

            // 遍历所有语言文件夹
            var langFolders = Directory.GetDirectories(bepInExPath);

            foreach (var langFolder in langFolders)
            {
                string textFolder = Path.Combine(langFolder, "Text");
                if (Directory.Exists(textFolder))
                {
                    string translationFile = Path.Combine(textFolder, "_AutoGeneratedTranslations.txt");
                    if (File.Exists(translationFile))
                    {
                        return translationFile;
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// 获取所有条目
        /// </summary>
        public List<TranslationEntry> GetEntries()
        {
            lock (_lockObject)
            {
                return _entries.ToList();
            }
        }

        /// <summary>
        /// 保存单个条目
        /// </summary>
        public async Task SaveEntryAsync(TranslationEntry entry)
        {
            if (_parser == null || _currentFilePath == null)
            {
                throw new Exception("没有加载的文件");
            }

            try
            {
                // 更新内存中的条目
                lock (_lockObject)
                {
                    var existingEntry = _entries.FirstOrDefault(e => e.Key == entry.Key);
                    if (existingEntry != null)
                    {
                        existingEntry.Value = entry.Value;
                        existingEntry.IsTranslated = !string.Equals(entry.Key, entry.Value, StringComparison.Ordinal);
                    }
                }

                // 更新解析器中的翻译
                _parser.UpdateTranslation(entry.Key, entry.Value);

                // 保存到文件
                await _parser.SaveFileAsync(_currentFilePath);

                await _logService.LogAsync($"保存条目成功: {entry.Key}", LogLevel.Info);

                EntriesUpdated?.Invoke(this, EventArgs.Empty);
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"保存条目失败: {ex.Message}", LogLevel.Error);
                throw new Exception($"保存条目失败: {ex.Message}", ex);
            }
        }

        /// <summary>
        /// 批量保存条目
        /// </summary>
        public async Task SaveEntriesAsync(List<TranslationEntry> entries)
        {
            if (_parser == null || _currentFilePath == null)
            {
                throw new Exception("没有加载的文件");
            }

            try
            {
                var translations = new Dictionary<string, string>();

                foreach (var entry in entries)
                {
                    translations[entry.Key] = entry.Value;

                    // 更新内存中的条目
                    lock (_lockObject)
                    {
                        var existingEntry = _entries.FirstOrDefault(e => e.Key == entry.Key);
                        if (existingEntry != null)
                        {
                            existingEntry.Value = entry.Value;
                            existingEntry.IsTranslated = !string.Equals(entry.Key, entry.Value, StringComparison.Ordinal);
                        }
                    }
                }

                // 批量更新
                _parser.UpdateTranslations(translations);

                // 保存到文件
                await _parser.SaveFileAsync(_currentFilePath);

                await _logService.LogAsync($"批量保存成功，共 {entries.Count} 条记录", LogLevel.Info);

                EntriesUpdated?.Invoke(this, EventArgs.Empty);
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"批量保存失败: {ex.Message}", LogLevel.Error);
                throw new Exception($"批量保存失败: {ex.Message}", ex);
            }
        }

        /// <summary>
        /// 搜索条目
        /// </summary>
        public List<TranslationEntry> SearchEntries(string keyword, bool searchKey = true, bool searchValue = true)
        {
            if (string.IsNullOrWhiteSpace(keyword))
            {
                return GetEntries();
            }

            lock (_lockObject)
            {
                return _entries.Where(e =>
                {
                    bool matchKey = searchKey && e.Key.Contains(keyword, StringComparison.OrdinalIgnoreCase);
                    bool matchValue = searchValue && e.Value.Contains(keyword, StringComparison.OrdinalIgnoreCase);
                    return matchKey || matchValue;
                }).ToList();
            }
        }

        /// <summary>
        /// 筛选未翻译的条目
        /// </summary>
        public List<TranslationEntry> FilterUntranslated()
        {
            lock (_lockObject)
            {
                return _entries.Where(e => !e.IsTranslated).ToList();
            }
        }

        /// <summary>
        /// 筛选已翻译的条目
        /// </summary>
        public List<TranslationEntry> FilterTranslated()
        {
            lock (_lockObject)
            {
                return _entries.Where(e => e.IsTranslated).ToList();
            }
        }

        /// <summary>
        /// 获取统计信息
        /// </summary>
        public FileStatistics? GetStatistics()
        {
            return _parser?.GetStatistics();
        }

        /// <summary>
        /// 获取当前文件路径
        /// </summary>
        public string? GetCurrentFilePath()
        {
            lock (_lockObject)
            {
                return _currentFilePath;
            }
        }

        /// <summary>
        /// 重新加载当前文件
        /// </summary>
        public async Task ReloadAsync()
        {
            string? filePath;
            lock (_lockObject)
            {
                filePath = _currentFilePath;
            }

            if (filePath != null)
            {
                await LoadFileAsync(filePath);
            }
        }

        /// <summary>
        /// 清空当前数据
        /// </summary>
        public void Clear()
        {
            lock (_lockObject)
            {
                _currentFilePath = null;
                _entries.Clear();
            }

            _parser?.Clear();
            _parser = null;
        }
    }
}

