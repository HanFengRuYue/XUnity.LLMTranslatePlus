using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;
using XUnity_LLMTranslatePlus.Models;
using XUnity_LLMTranslatePlus.Utils;

namespace XUnity_LLMTranslatePlus.Services
{
    /// <summary>
    /// 文件监控服务
    /// </summary>
    public class FileMonitorService : IDisposable
    {
        private readonly TranslationService _translationService;
        private readonly LogService _logService;
        private readonly ConfigService _configService;
        private readonly ApiPoolManager? _apiPoolManager;

        private FileSystemWatcher? _fileWatcher;
        private TextFileParser? _parser;
        private string? _monitoredFilePath;
        private bool _isMonitoring;
        private readonly object _lockObject = new object();

        // 待处理的文本Channel（替代Queue以支持高性能持续并发）
        private Channel<string>? _pendingTexts;

        // 已处理的文本集合（防止重复翻译）
        private readonly HashSet<string> _processedTexts = new HashSet<string>();

        // 取消标记源（用于优雅停止）
        private CancellationTokenSource? _cancellationTokenSource;

        // 消费者任务列表（持续并发翻译）
        private List<Task>? _consumerTasks;

        // 批量写入机制
        private readonly Channel<Dictionary<string, string>> _writeQueue;
        private Task? _writerTask;
        private readonly TimeSpan _batchWriteInterval = TimeSpan.FromSeconds(2);
        private const int BatchWriteSize = 5;

        public event EventHandler<FileMonitorEventArgs>? StatusChanged;
        public event EventHandler<TranslationEntry>? EntryTranslated;
        public event EventHandler<string>? ErrorThresholdReached;

        public bool IsMonitoring
        {
            get
            {
                lock (_lockObject)
                {
                    return _isMonitoring;
                }
            }
        }

        /// <summary>
        /// 获取当前监控的文件路径
        /// </summary>
        public string? MonitoredFilePath => _monitoredFilePath;

        public FileMonitorService(
            TranslationService translationService,
            LogService logService,
            ConfigService configService,
            ApiPoolManager? apiPoolManager = null)
        {
            _translationService = translationService;
            _logService = logService;
            _configService = configService;
            _apiPoolManager = apiPoolManager;

            // 初始化批量写入队列
            _writeQueue = Channel.CreateUnbounded<Dictionary<string, string>>(new UnboundedChannelOptions
            {
                SingleReader = true,
                SingleWriter = false
            });
        }

        /// <summary>
        /// 开始监控
        /// </summary>
        public async Task StartMonitoringAsync(string gameDirectory)
        {
            if (IsMonitoring)
            {
                await _logService.LogAsync("监控已经在运行中", LogLevel.Warning);
                return;
            }

            try
            {
                string? filePath = null;
                var config = _configService.GetCurrentConfig();

                // 优先使用手动指定的文件路径
                if (!string.IsNullOrWhiteSpace(config.ManualTranslationFilePath))
                {
                    if (File.Exists(config.ManualTranslationFilePath))
                    {
                        filePath = config.ManualTranslationFilePath;
                        await _logService.LogAsync($"使用手动指定的翻译文件: {filePath}", LogLevel.Info);
                    }
                    else
                    {
                        await _logService.LogAsync($"手动指定的文件不存在，尝试自动检测: {config.ManualTranslationFilePath}", LogLevel.Warning);
                    }
                }

                // 如果没有手动路径或手动路径无效，使用自动检测
                if (filePath == null)
                {
                    // 验证游戏目录路径
                    PathValidator.ValidateDirectoryExists(gameDirectory);
                    string validatedGameDir = PathValidator.ValidateAndNormalizePath(gameDirectory);

                    // 查找 _AutoGeneratedTranslations.txt 文件
                    filePath = FindTranslationFile(validatedGameDir);

                    if (filePath == null)
                    {
                        throw new Exception($"在游戏目录中未找到 _AutoGeneratedTranslations.txt 文件: {validatedGameDir}");
                    }

                    await _logService.LogAsync($"自动检测到翻译文件: {filePath}", LogLevel.Info);
                }

                // 验证翻译文件路径
                PathValidator.ValidateFileExists(filePath);

                _monitoredFilePath = filePath;
                _parser = new TextFileParser();

                // 初始化取消标记
                _cancellationTokenSource = new CancellationTokenSource();

                // 初始化Channel（无界通道，支持高吞吐量） - 必须在 LoadAndProcessFileAsync 之前
                _pendingTexts = Channel.CreateUnbounded<string>(new UnboundedChannelOptions
                {
                    SingleReader = false,  // 多个消费者
                    SingleWriter = false   // 可能有多个生产者（文件监控、初始加载）
                });

                // 清空已处理文本集合（必须在 LoadAndProcessFileAsync 之前）
                lock (_processedTexts)
                {
                    _processedTexts.Clear();
                }

                // 初始加载文件
                await LoadAndProcessFileAsync();

                // 设置文件监控
                string? directory = Path.GetDirectoryName(filePath);
                if (directory != null)
                {
                    _fileWatcher = new FileSystemWatcher(directory)
                    {
                        Filter = Path.GetFileName(filePath),
                        NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.Size,
                        EnableRaisingEvents = true
                    };

                    _fileWatcher.Changed += OnFileChanged;
                }

                lock (_lockObject)
                {
                    _isMonitoring = true;
                }

                // 初始化 API 池（在启动消费者前，防止并发初始化冲突）
                if (_apiPoolManager != null)
                {
                    await _apiPoolManager.EnsureInitializedAsync(_cancellationTokenSource.Token);
                }

                // 启动消费者任务池（持续并发翻译）
                StartConsumerTasks(_configService.GetCurrentConfig());

                // 启动批量写入任务
                StartWriterTask();

                await _logService.LogAsync("文件监控已启动", LogLevel.Info);
                NotifyStatusChanged("运行中", true);
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"启动监控失败: {ex.Message}", LogLevel.Error);
                throw;
            }
        }

        /// <summary>
        /// 停止监控
        /// </summary>
        public async Task StopMonitoringAsync()
        {
            if (!IsMonitoring)
            {
                return;
            }

            lock (_lockObject)
            {
                _isMonitoring = false;
            }

            // 取消所有正在进行的操作
            _cancellationTokenSource?.Cancel();

            // 停止Channel写入
            _pendingTexts?.Writer.Complete();
            _writeQueue.Writer.Complete();

            // 等待批量写入任务完成
            if (_writerTask != null)
            {
                try
                {
                    await _writerTask.WaitAsync(TimeSpan.FromSeconds(5));
                }
                catch (TimeoutException)
                {
                    await _logService.LogAsync("等待写入任务完成超时", LogLevel.Warning);
                }
                _writerTask = null;
            }

            // 等待所有消费者任务完成（最多等待5秒）
            if (_consumerTasks != null && _consumerTasks.Count > 0)
            {
                try
                {
                    await Task.WhenAll(_consumerTasks).WaitAsync(TimeSpan.FromSeconds(5));
                }
                catch (OperationCanceledException)
                {
                    // 正常取消，忽略
                }
                catch (TimeoutException)
                {
                    await _logService.LogAsync("等待消费者任务完成超时", LogLevel.Warning);
                }
                _consumerTasks.Clear();
                _consumerTasks = null;
            }

            // 停止文件监控
            if (_fileWatcher != null)
            {
                _fileWatcher.EnableRaisingEvents = false;
                _fileWatcher.Changed -= OnFileChanged;
                _fileWatcher.Dispose();
                _fileWatcher = null;
            }

            // 清空Channel和已处理集合
            _pendingTexts = null;

            lock (_processedTexts)
            {
                _processedTexts.Clear();
            }

            // 释放取消标记源
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;

            // 重置 API 池初始化状态（下次启动时重新初始化）
            if (_apiPoolManager != null)
            {
                try
                {
                    await _apiPoolManager.ResetAsync();
                }
                catch (Exception ex)
                {
                    await _logService.LogAsync($"重置API池失败: {ex.Message}", LogLevel.Warning);
                }
            }

            _parser?.Clear();
            _parser = null;
            _monitoredFilePath = null;

            await _logService.LogAsync("文件监控已停止", LogLevel.Info);
            NotifyStatusChanged("已停止", false);
        }

        /// <summary>
        /// 查找翻译文件
        /// </summary>
        private string? FindTranslationFile(string gameDirectory)
        {
            string bepInExPath = Path.Combine(gameDirectory, "BepInEx", "Translation");

            if (!Directory.Exists(bepInExPath))
            {
                return null;
            }

            // 遍历所有语言文件夹
            var langFolders = Directory.GetDirectories(bepInExPath);

            foreach (var langFolder in langFolders)
            {
                string textFolder = Path.Combine(langFolder, "Text");
                if (Directory.Exists(textFolder))
                {
                    string translationFile = Path.Combine(textFolder, "_AutoGeneratedTranslations.txt");
                    if (File.Exists(translationFile))
                    {
                        return translationFile;
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// 文件变化事件处理（优化延迟从500ms降至200ms）
        /// </summary>
        private void OnFileChanged(object sender, FileSystemEventArgs e)
        {
            _ = Task.Run(async () =>
            {
                try
                {
                    await Task.Delay(200); // 优化：等待时间从500ms降至200ms
                    await LoadAndProcessFileAsync();
                }
                catch (Exception ex)
                {
                    await _logService.LogAsync($"处理文件变化失败: {ex.Message}", LogLevel.Error);
                }
            });
        }

        /// <summary>
        /// 加载并处理文件
        /// </summary>
        private async Task LoadAndProcessFileAsync()
        {
            // 使用局部变量避免多线程竞态条件
            var parser = _parser;
            var filePath = _monitoredFilePath;

            if (parser == null || filePath == null)
            {
                return;
            }

            try
            {
                var entries = await parser.ParseFileAsync(filePath);

                // 检查 entries 是否为 null
                if (entries == null)
                {
                    await _logService.LogAsync("文件解析返回 null", LogLevel.Warning);
                    return;
                }

                var untranslated = parser.GetUntranslatedEntries(entries);

                if (untranslated.Count > 0)
                {
                    await _logService.LogAsync($"发现 {untranslated.Count} 条未翻译文本", LogLevel.Info);

                    // 添加到待处理Channel（检查是否已处理）
                    int addedCount = 0;
                    int removedFromCacheCount = 0;
                    var removedPreviews = new List<string>();

                    foreach (var entry in untranslated)
                    {
                        // 如果是未翻译的，从已处理集合中移除（允许重新翻译）
                        bool wasInCache = false;
                        bool shouldAdd = false;

                        lock (_processedTexts)
                        {
                            if (_processedTexts.Contains(entry.Key))
                            {
                                _processedTexts.Remove(entry.Key);
                                removedFromCacheCount++;
                                wasInCache = true;
                            }

                            // 检查是否应该添加（未在已处理集合中）
                            if (!_processedTexts.Contains(entry.Key))
                            {
                                shouldAdd = true;
                            }
                        }

                        if (wasInCache)
                        {
                            string preview = entry.Key.Length > 50
                                ? entry.Key.AsSpan(0, 50).ToString() + "..."
                                : entry.Key;
                            removedPreviews.Add(preview);
                        }

                        // 添加到Channel（非阻塞）
                        if (shouldAdd && _pendingTexts != null)
                        {
                            if (_pendingTexts.Writer.TryWrite(entry.Key))
                            {
                                addedCount++;
                            }
                        }
                    }

                    // 记录所有从缓存中移除的文本
                    foreach (var preview in removedPreviews)
                    {
                        await _logService.LogAsync($"[重新翻译] 从缓存中移除: {preview}", LogLevel.Info);
                    }

                    if (addedCount > 0)
                    {
                        await _logService.LogAsync($"新增 {addedCount} 条待翻译文本到队列", LogLevel.Info);
                    }

                    if (removedFromCacheCount > 0)
                    {
                        await _logService.LogAsync($"从缓存中移除 {removedFromCacheCount} 条需要重新翻译的文本", LogLevel.Info);
                    }
                }
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"加载文件失败: {ex.Message}", LogLevel.Error);
            }
        }

        /// <summary>
        /// 启动消费者任务池（持续并发翻译）
        /// </summary>
        private void StartConsumerTasks(AppConfig config)
        {
            _consumerTasks = new List<Task>();

            // 从所有启用的API端点计算总并发容量
            var enabledEndpoints = config.ApiEndpoints.Where(e => e.IsEnabled).ToList();
            int totalConcurrent = enabledEndpoints.Sum(e => e.MaxConcurrent);
            int consumerCount = Math.Min(totalConcurrent, 100); // 上限100，防止过度消耗资源

            // 如果没有启用的端点或并发数为0，使用默认值3
            if (consumerCount == 0)
            {
                consumerCount = 3;
                _logService.Log("未配置启用的API端点，使用默认并发数: 3", LogLevel.Warning);
            }

            for (int i = 0; i < consumerCount; i++)
            {
                int consumerId = i + 1;
                var task = Task.Run(async () => await ConsumerTaskAsync(consumerId));
                _consumerTasks.Add(task);
            }

            _logService.Log($"已启动 {consumerCount} 个并发翻译任务（基于 {enabledEndpoints.Count} 个API端点）", LogLevel.Info);
        }

        /// <summary>
        /// 消费者任务（持续从Channel读取并翻译）
        /// </summary>
        private async Task ConsumerTaskAsync(int consumerId)
        {
            if (_pendingTexts == null || _cancellationTokenSource == null)
            {
                return;
            }

            var cancellationToken = _cancellationTokenSource.Token;

            await _logService.LogAsync($"[消费者{consumerId}] 已启动", LogLevel.Debug);

            try
            {
                // 持续从Channel读取直到取消或Channel关闭
                await foreach (var text in _pendingTexts.Reader.ReadAllAsync(cancellationToken))
                {
                    // 检查是否已停止监控
                    if (!IsMonitoring || _parser == null || _monitoredFilePath == null)
                    {
                        break;
                    }

                    // 检查错误阈值
                    var config = _configService.GetCurrentConfig();
                    if (_translationService.TotalFailed >= config.ErrorThreshold)
                    {
                        await _logService.LogAsync($"错误数量已达到阈值 ({config.ErrorThreshold})，停止监控", LogLevel.Error);
                        ErrorThresholdReached?.Invoke(this, $"翻译错误过多（{_translationService.TotalFailed}次），已自动停止监控。请检查API配置和网络连接。");
                        _ = StopMonitoringAsync();
                        break;
                    }

                    // 检查是否已处理
                    bool shouldProcess = false;
                    lock (_processedTexts)
                    {
                        if (!_processedTexts.Contains(text))
                        {
                            _processedTexts.Add(text);
                            shouldProcess = true;
                        }
                    }

                    if (!shouldProcess)
                    {
                        await _logService.LogAsync($"[消费者{consumerId}] 跳过已处理文本", LogLevel.Debug);
                        continue;
                    }

                    try
                    {
                        // 优化：移除每次翻译前的文件解析，直接翻译
                        string preview = text.Length > 50 ? text.AsSpan(0, 50).ToString() + "..." : text;
                        if (text.Contains("\\n") || text.Contains("\\r") || text.Contains("\\t"))
                        {
                            await _logService.LogAsync($"[消费者{consumerId}][待翻译-含转义] {preview}", LogLevel.Info);
                        }

                        await _logService.LogAsync($"[消费者{consumerId}] 正在翻译: {preview}", LogLevel.Info);

                        // 执行翻译
                        string translated = await _translationService.TranslateTextAsync(text, config, cancellationToken);

                        // 再次检查状态（翻译可能耗时较长）
                        if (!IsMonitoring || _parser == null || _monitoredFilePath == null)
                        {
                            break;
                        }

                        // 如果翻译结果和原文一致，跳过保存
                        if (string.Equals(text, translated, StringComparison.Ordinal))
                        {
                            await _logService.LogAsync($"[消费者{consumerId}] 跳过（原文和译文相同）", LogLevel.Info);
                            continue;
                        }

                        // 更新内存中的翻译
                        _parser.UpdateTranslation(text, translated);

                        // 加入批量写入队列而不是立即写入（使用 TryWrite 避免 Channel 关闭时抛出异常）
                        var batch = new Dictionary<string, string> { { text, translated } };
                        if (!_writeQueue.Writer.TryWrite(batch))
                        {
                            // Channel 已关闭，记录日志但不抛出异常
                            await _logService.LogAsync($"[消费者{consumerId}] 写入队列已关闭，跳过写入", LogLevel.Debug);
                            break;
                        }

                        await _logService.LogAsync($"[消费者{consumerId}] 翻译完成: {preview} -> {translated}", LogLevel.Info);

                        // 通知 UI
                        EntryTranslated?.Invoke(this, new TranslationEntry
                        {
                            Key = text,
                            Value = translated,
                            IsTranslated = true
                        });
                    }
                    catch (OperationCanceledException)
                    {
                        // 取消操作，退出循环
                        break;
                    }
                    catch (Exception ex)
                    {
                        await _logService.LogAsync($"[消费者{consumerId}] 翻译失败: {ex.Message}", LogLevel.Error);

                        // 翻译失败时从已处理集合中移除，允许重试
                        lock (_processedTexts)
                        {
                            _processedTexts.Remove(text);
                        }
                    }
                }
            }
            catch (OperationCanceledException)
            {
                // 正常取消，忽略
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"[消费者{consumerId}] 异常退出: {ex.Message}", LogLevel.Error);
            }

            await _logService.LogAsync($"[消费者{consumerId}] 已停止", LogLevel.Debug);
        }

        /// <summary>
        /// 启动批量写入任务
        /// </summary>
        private void StartWriterTask()
        {
            _writerTask = Task.Run(async () => await BatchWriterTaskAsync());
            _logService.Log("批量写入任务已启动", LogLevel.Info);
        }

        /// <summary>
        /// 批量写入任务（定期批量写入文件，减少写入冲突）
        /// </summary>
        private async Task BatchWriterTaskAsync()
        {
            if (_cancellationTokenSource == null)
            {
                return;
            }

            var cancellationToken = _cancellationTokenSource.Token;
            var pendingWrites = new List<Dictionary<string, string>>();
            var lastWriteTime = DateTime.UtcNow;

            await _logService.LogAsync("[批量写入] 任务已启动", LogLevel.Debug);

            try
            {
                while (!cancellationToken.IsCancellationRequested)
                {
                    try
                    {
                        // 使用 WaitToReadAsync 配合 TryRead 避免 continuation 冲突
                        var waitToReadTask = _writeQueue.Reader.WaitToReadAsync(cancellationToken).AsTask();
                        var timeoutTask = Task.Delay(500, cancellationToken);

                        var completedTask = await Task.WhenAny(waitToReadTask, timeoutTask);

                        // 如果有数据可读，尝试读取
                        if (completedTask == waitToReadTask && await waitToReadTask)
                        {
                            while (_writeQueue.Reader.TryRead(out var batch))
                            {
                                pendingWrites.Add(batch);
                            }
                        }

                        // 检查是否应该写入（达到批次大小或超时）
                        var timeSinceLastWrite = DateTime.UtcNow - lastWriteTime;
                        bool shouldWrite = pendingWrites.Count >= BatchWriteSize ||
                                          (pendingWrites.Count > 0 && timeSinceLastWrite >= _batchWriteInterval);

                        if (shouldWrite && _parser != null && _monitoredFilePath != null)
                        {
                            await _logService.LogAsync($"[批量写入] 开始写入 {pendingWrites.Count} 个批次", LogLevel.Info);

                            // 合并所有待写入的翻译
                            var mergedTranslations = new Dictionary<string, string>();
                            foreach (var batch in pendingWrites)
                            {
                                foreach (var kvp in batch)
                                {
                                    mergedTranslations[kvp.Key] = kvp.Value;
                                }
                            }

                            // 临时禁用文件监控，防止写入触发监控循环
                            bool wasMonitoring = false;
                            if (_fileWatcher != null && _fileWatcher.EnableRaisingEvents)
                            {
                                _fileWatcher.EnableRaisingEvents = false;
                                wasMonitoring = true;
                            }

                            try
                            {
                                // 批量更新并保存文件
                                _parser.UpdateTranslations(mergedTranslations);
                                await _parser.SaveFileAsync(_monitoredFilePath, cancellationToken);

                                await _logService.LogAsync($"[批量写入] 已写入 {mergedTranslations.Count} 条翻译到文件", LogLevel.Info);

                                // 等待文件系统稳定（防止写入后立即触发监控）
                                await Task.Delay(300, cancellationToken);
                            }
                            finally
                            {
                                // 恢复文件监控
                                if (wasMonitoring && _fileWatcher != null)
                                {
                                    _fileWatcher.EnableRaisingEvents = true;
                                }
                            }

                            pendingWrites.Clear();
                            lastWriteTime = DateTime.UtcNow;
                        }
                    }
                    catch (ChannelClosedException)
                    {
                        // Channel 已关闭，写入剩余数据后退出
                        if (pendingWrites.Count > 0 && _parser != null && _monitoredFilePath != null)
                        {
                            var mergedTranslations = new Dictionary<string, string>();
                            foreach (var batch in pendingWrites)
                            {
                                foreach (var kvp in batch)
                                {
                                    mergedTranslations[kvp.Key] = kvp.Value;
                                }
                            }
                            _parser.UpdateTranslations(mergedTranslations);
                            await _parser.SaveFileAsync(_monitoredFilePath);
                            await _logService.LogAsync($"[批量写入] 最终写入 {mergedTranslations.Count} 条翻译", LogLevel.Info);
                        }
                        break;
                    }
                }
            }
            catch (OperationCanceledException)
            {
                // 正常取消，忽略
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"[批量写入] 异常退出: {ex.Message}", LogLevel.Error);
            }

            await _logService.LogAsync("[批量写入] 任务已停止", LogLevel.Debug);
        }

        /// <summary>
        /// 通知状态变化
        /// </summary>
        private void NotifyStatusChanged(string status, bool isMonitoring)
        {
            StatusChanged?.Invoke(this, new FileMonitorEventArgs
            {
                Status = status,
                IsMonitoring = isMonitoring,
                FilePath = _monitoredFilePath
            });
        }

        /// <summary>
        /// 获取当前统计信息
        /// </summary>
        public FileStatistics? GetStatistics()
        {
            return _parser?.GetStatistics();
        }

        /// <summary>
        /// 获取待处理文本数量
        /// </summary>
        public int GetPendingCount()
        {
            // Channel不直接提供Count，返回Reader中可用的近似数量
            // 注意：这是一个估算值，实际数量可能略有不同
            return _pendingTexts?.Reader.CanCount == true
                ? _pendingTexts.Reader.Count
                : 0;
        }

        public void Dispose()
        {
            _ = StopMonitoringAsync();
        }
    }

    /// <summary>
    /// 文件监控事件参数
    /// </summary>
    public class FileMonitorEventArgs : EventArgs
    {
        public string Status { get; set; } = "";
        public bool IsMonitoring { get; set; }
        public string? FilePath { get; set; }
    }
}

