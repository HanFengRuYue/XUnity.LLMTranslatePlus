using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using XUnity_LLMTranslatePlus.Models;
using XUnity_LLMTranslatePlus.Utils;

namespace XUnity_LLMTranslatePlus.Services
{
    /// <summary>
    /// 文件监控服务
    /// </summary>
    public class FileMonitorService : IDisposable
    {
        private readonly TranslationService _translationService;
        private readonly LogService _logService;
        private readonly ConfigService _configService;

        private FileSystemWatcher? _fileWatcher;
        private TextFileParser? _parser;
        private string? _monitoredFilePath;
        private bool _isMonitoring;
        private Timer? _processTimer;
        private readonly object _lockObject = new object();

        // 待处理的文本队列
        private readonly Queue<string> _pendingTexts = new Queue<string>();
        
        // 已处理的文本集合（防止重复翻译）
        private readonly HashSet<string> _processedTexts = new HashSet<string>();
        
        // 取消标记源（用于优雅停止）
        private CancellationTokenSource? _cancellationTokenSource;

        public event EventHandler<FileMonitorEventArgs>? StatusChanged;
        public event EventHandler<TranslationEntry>? EntryTranslated;
        public event EventHandler<string>? ErrorThresholdReached;

        public bool IsMonitoring
        {
            get
            {
                lock (_lockObject)
                {
                    return _isMonitoring;
                }
            }
        }

        /// <summary>
        /// 获取当前监控的文件路径
        /// </summary>
        public string? MonitoredFilePath => _monitoredFilePath;

        public FileMonitorService(
            TranslationService translationService,
            LogService logService,
            ConfigService configService)
        {
            _translationService = translationService;
            _logService = logService;
            _configService = configService;
        }

        /// <summary>
        /// 开始监控
        /// </summary>
        public async Task StartMonitoringAsync(string gameDirectory)
        {
            if (IsMonitoring)
            {
                await _logService.LogAsync("监控已经在运行中", LogLevel.Warning);
                return;
            }

            try
            {
                // 验证游戏目录路径
                PathValidator.ValidateDirectoryExists(gameDirectory);
                string validatedGameDir = PathValidator.ValidateAndNormalizePath(gameDirectory);

                // 查找 _AutoGeneratedTranslations.txt 文件
                string? filePath = FindTranslationFile(validatedGameDir);

                if (filePath == null)
                {
                    throw new Exception($"在游戏目录中未找到 _AutoGeneratedTranslations.txt 文件: {validatedGameDir}");
                }

                // 验证翻译文件路径
                PathValidator.ValidateFileExists(filePath);

                await _logService.LogAsync($"找到翻译文件: {filePath}", LogLevel.Info);

                _monitoredFilePath = filePath;
                _parser = new TextFileParser();

                // 初始加载文件
                await LoadAndProcessFileAsync();

                // 设置文件监控
                string? directory = Path.GetDirectoryName(filePath);
                if (directory != null)
                {
                    _fileWatcher = new FileSystemWatcher(directory)
                    {
                        Filter = Path.GetFileName(filePath),
                        NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.Size,
                        EnableRaisingEvents = true
                    };

                    _fileWatcher.Changed += OnFileChanged;
                }

                // 初始化取消标记
                _cancellationTokenSource = new CancellationTokenSource();
                
                // 清空已处理文本集合
                lock (_processedTexts)
                {
                    _processedTexts.Clear();
                }

                // 启动定时处理器（每 5 秒处理一次待翻译队列）
                _processTimer = new Timer(ProcessPendingTextsCallback, null, TimeSpan.FromSeconds(5), TimeSpan.FromSeconds(5));

                lock (_lockObject)
                {
                    _isMonitoring = true;
                }

                await _logService.LogAsync("文件监控已启动", LogLevel.Info);
                NotifyStatusChanged("运行中", true);
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"启动监控失败: {ex.Message}", LogLevel.Error);
                throw;
            }
        }

        /// <summary>
        /// 停止监控
        /// </summary>
        public async Task StopMonitoringAsync()
        {
            if (!IsMonitoring)
            {
                return;
            }

            lock (_lockObject)
            {
                _isMonitoring = false;
            }

            // 取消所有正在进行的操作
            _cancellationTokenSource?.Cancel();

            // 停止定时器
            _processTimer?.Change(Timeout.Infinite, Timeout.Infinite);
            _processTimer?.Dispose();
            _processTimer = null;

            // 等待正在进行的任务完成（最多等待 2 秒）
            await Task.Delay(100);

            // 停止文件监控
            if (_fileWatcher != null)
            {
                _fileWatcher.EnableRaisingEvents = false;
                _fileWatcher.Changed -= OnFileChanged;
                _fileWatcher.Dispose();
                _fileWatcher = null;
            }

            // 清空队列和已处理集合
            lock (_pendingTexts)
            {
                _pendingTexts.Clear();
            }
            
            lock (_processedTexts)
            {
                _processedTexts.Clear();
            }

            // 释放取消标记源
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;

            _parser?.Clear();
            _parser = null;
            _monitoredFilePath = null;

            await _logService.LogAsync("文件监控已停止", LogLevel.Info);
            NotifyStatusChanged("已停止", false);
        }

        /// <summary>
        /// 查找翻译文件
        /// </summary>
        private string? FindTranslationFile(string gameDirectory)
        {
            string bepInExPath = Path.Combine(gameDirectory, "BepInEx", "Translation");

            if (!Directory.Exists(bepInExPath))
            {
                return null;
            }

            // 遍历所有语言文件夹
            var langFolders = Directory.GetDirectories(bepInExPath);

            foreach (var langFolder in langFolders)
            {
                string textFolder = Path.Combine(langFolder, "Text");
                if (Directory.Exists(textFolder))
                {
                    string translationFile = Path.Combine(textFolder, "_AutoGeneratedTranslations.txt");
                    if (File.Exists(translationFile))
                    {
                        return translationFile;
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// 文件变化事件处理
        /// </summary>
        private void OnFileChanged(object sender, FileSystemEventArgs e)
        {
            _ = Task.Run(async () =>
            {
                try
                {
                    await Task.Delay(500); // 等待文件写入完成
                    await LoadAndProcessFileAsync();
                }
                catch (Exception ex)
                {
                    await _logService.LogAsync($"处理文件变化失败: {ex.Message}", LogLevel.Error);
                }
            });
        }

        /// <summary>
        /// 加载并处理文件
        /// </summary>
        private async Task LoadAndProcessFileAsync()
        {
            if (_parser == null || _monitoredFilePath == null)
            {
                return;
            }

            try
            {
                var entries = await _parser.ParseFileAsync(_monitoredFilePath);
                var untranslated = _parser.GetUntranslatedEntries(entries);

                if (untranslated.Count > 0)
                {
                    await _logService.LogAsync($"发现 {untranslated.Count} 条未翻译文本", LogLevel.Info);

                    // 添加到待处理队列（检查是否已处理或已在队列中）
                    int addedCount = 0;
                    int removedFromCacheCount = 0;
                    var removedPreviews = new List<string>();
                    
                    foreach (var entry in untranslated)
                    {
                        // 如果是未翻译的，从已处理集合中移除（允许重新翻译）
                        bool wasInCache = false;
                        lock (_processedTexts)
                        {
                            if (_processedTexts.Contains(entry.Key))
                            {
                                _processedTexts.Remove(entry.Key);
                                removedFromCacheCount++;
                                wasInCache = true;
                            }
                        }
                        
                        if (wasInCache)
                        {
                            string preview = entry.Key.Length > 50
                                ? entry.Key.AsSpan(0, 50).ToString() + "..."
                                : entry.Key;
                            removedPreviews.Add(preview);
                        }
                        
                        // 添加到队列
                        lock (_pendingTexts)
                        {
                            if (!_pendingTexts.Contains(entry.Key))
                            {
                                _pendingTexts.Enqueue(entry.Key);
                                addedCount++;
                            }
                        }
                    }
                    
                    // 记录所有从缓存中移除的文本
                    foreach (var preview in removedPreviews)
                    {
                        await _logService.LogAsync($"[重新翻译] 从缓存中移除: {preview}", LogLevel.Info);
                    }
                    
                    if (addedCount > 0)
                    {
                        await _logService.LogAsync($"新增 {addedCount} 条待翻译文本到队列", LogLevel.Info);
                    }
                    
                    if (removedFromCacheCount > 0)
                    {
                        await _logService.LogAsync($"从缓存中移除 {removedFromCacheCount} 条需要重新翻译的文本", LogLevel.Info);
                    }
                }
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"加载文件失败: {ex.Message}", LogLevel.Error);
            }
        }

        /// <summary>
        /// 定时处理待翻译文本
        /// </summary>
        private void ProcessPendingTextsCallback(object? state)
        {
            // 检查是否已请求取消
            if (_cancellationTokenSource?.IsCancellationRequested == true)
            {
                return;
            }
            
            _ = Task.Run(ProcessPendingTextsAsync);
        }

        /// <summary>
        /// 处理待翻译文本
        /// </summary>
        private async Task ProcessPendingTextsAsync()
        {
            // 检查取消请求
            if (_cancellationTokenSource?.IsCancellationRequested == true)
            {
                return;
            }

            if (!IsMonitoring || _parser == null || _monitoredFilePath == null)
            {
                return;
            }

            var config = _configService.GetCurrentConfig();

            // 检查错误阈值
            if (_translationService.TotalFailed >= config.ErrorThreshold)
            {
                await _logService.LogAsync($"错误数量已达到阈值 ({config.ErrorThreshold})，停止监控", LogLevel.Error);
                ErrorThresholdReached?.Invoke(this, $"翻译错误过多（{_translationService.TotalFailed}次），已自动停止监控。请检查API配置和网络连接。");
                await StopMonitoringAsync();
                return;
            }

            // 统一使用批量处理方式，根据 MaxConcurrentTranslations 控制并发
            await ProcessBatchAsync(config);
        }

        /// <summary>
        /// 批量处理待翻译文本
        /// </summary>
        private async Task ProcessBatchAsync(AppConfig config)
        {
            // 从队列中取出一批待处理文本
            // 每次处理的数量为并发数的2倍，既保证效率又避免一次取太多
            var textsToProcess = new List<string>();
            lock (_pendingTexts)
            {
                int batchSize = Math.Max(1, config.MaxConcurrentTranslations * 2);
                int count = Math.Min(batchSize, _pendingTexts.Count);
                for (int i = 0; i < count; i++)
                {
                    if (_pendingTexts.Count > 0)
                    {
                        textsToProcess.Add(_pendingTexts.Dequeue());
                    }
                }
            }

            if (textsToProcess.Count == 0)
            {
                return;
            }

            // 过滤已处理的文本
            var filteredTexts = new List<string>();
            lock (_processedTexts)
            {
                foreach (var text in textsToProcess)
                {
                    if (!_processedTexts.Contains(text))
                    {
                        _processedTexts.Add(text);
                        filteredTexts.Add(text);
                    }
                }
            }

            if (filteredTexts.Count == 0)
            {
                await _logService.LogAsync($"批次中的所有文本都已处理，跳过", LogLevel.Debug);
                return;
            }

            await _logService.LogAsync($"开始批量翻译 {filteredTexts.Count} 条文本（最大并发: {config.MaxConcurrentTranslations}）", LogLevel.Info);

            try
            {
                // 验证哪些文本仍需翻译
                var currentEntries = await _parser!.ParseFileAsync(_monitoredFilePath!);
                var textsNeedTranslation = new List<string>();

                foreach (var text in filteredTexts)
                {
                    var entry = currentEntries.FirstOrDefault(e => e.Key == text);
                    if (entry != null && !entry.IsTranslated)
                    {
                        textsNeedTranslation.Add(text);

                        // 调试日志：显示待翻译文本的前50个字符，便于追踪转义字符
                        string preview = text.Length > 50
                            ? text.AsSpan(0, 50).ToString() + "..."
                            : text;
                        if (text.Contains("\\n") || text.Contains("\\r") || text.Contains("\\t"))
                        {
                            await _logService.LogAsync($"[待翻译-含转义] {preview}", LogLevel.Info);
                        }
                    }
                }

                if (textsNeedTranslation.Count == 0)
                {
                    await _logService.LogAsync($"批次中的所有文本都已被翻译，跳过", LogLevel.Info);
                    return;
                }

                // 调用批量翻译服务（内部会并发处理）
                var results = await _translationService.TranslateBatchAsync(textsNeedTranslation, config);

                // 检查取消请求
                if (_cancellationTokenSource?.IsCancellationRequested == true)
                {
                    await _logService.LogAsync($"批量翻译已取消", LogLevel.Info);
                    lock (_processedTexts)
                    {
                        foreach (var text in filteredTexts)
                        {
                            _processedTexts.Remove(text);
                        }
                    }
                    return;
                }

                // 防御性空检查
                if (_parser == null || _monitoredFilePath == null)
                {
                    await _logService.LogAsync($"批量翻译完成但监控已停止，跳过保存", LogLevel.Warning);
                    return;
                }

                // 更新所有翻译结果
                int successCount = 0;
                foreach (var result in results)
                {
                    if (!string.Equals(result.Key, result.Value, StringComparison.Ordinal))
                    {
                        _parser.UpdateTranslation(result.Key, result.Value);
                        successCount++;

                        // 通知 UI
                        EntryTranslated?.Invoke(this, new TranslationEntry
                        {
                            Key = result.Key,
                            Value = result.Value,
                            IsTranslated = true
                        });
                    }
                }

                // 一次性保存文件
                if (successCount > 0)
                {
                    await _parser.SaveFileAsync(_monitoredFilePath);
                    await _logService.LogAsync($"批量翻译完成: 成功 {successCount}/{filteredTexts.Count} 条", LogLevel.Info);
                }
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"批量翻译失败: {ex.Message}", LogLevel.Error);

                // 翻译失败时从已处理集合中移除，允许重试
                lock (_processedTexts)
                {
                    foreach (var text in filteredTexts)
                    {
                        _processedTexts.Remove(text);
                    }
                }
            }
        }

        /// <summary>
        /// 单条处理待翻译文本
        /// </summary>
        private async Task ProcessSingleAsync(AppConfig config)
        {
            // 每次只处理一条
            string? textToProcess = null;
            lock (_pendingTexts)
            {
                if (_pendingTexts.Count > 0)
                {
                    textToProcess = _pendingTexts.Dequeue();
                }
            }

            if (textToProcess == null)
            {
                return;
            }

            // 立即标记为正在处理，防止在翻译期间被重复加入队列
            bool wasAlreadyProcessed = false;
            lock (_processedTexts)
            {
                if (_processedTexts.Contains(textToProcess))
                {
                    wasAlreadyProcessed = true;
                }
                else
                {
                    _processedTexts.Add(textToProcess);
                }
            }

            // 如果已经处理过，直接返回
            if (wasAlreadyProcessed)
            {
                await _logService.LogAsync($"跳过翻译（已标记为处理）: {textToProcess}", LogLevel.Debug);
                return;
            }

            // 检查取消请求
            if (_cancellationTokenSource?.IsCancellationRequested == true)
            {
                lock (_processedTexts)
                {
                    _processedTexts.Remove(textToProcess);
                }
                return;
            }

            if (!IsMonitoring || _parser == null || _monitoredFilePath == null)
            {
                lock (_processedTexts)
                {
                    _processedTexts.Remove(textToProcess);
                }
                return;
            }

            // 再次检查错误阈值
            if (_translationService.TotalFailed >= config.ErrorThreshold)
            {
                await _logService.LogAsync($"错误数量已达到阈值 ({config.ErrorThreshold})，停止监控", LogLevel.Error);
                ErrorThresholdReached?.Invoke(this, $"翻译错误过多（{_translationService.TotalFailed}次），已自动停止监控。请检查API配置和网络连接。");
                await StopMonitoringAsync();
                return;
            }

            try
            {
                // 验证文本是否仍需翻译
                var currentEntries = await _parser.ParseFileAsync(_monitoredFilePath);
                var entry = currentEntries.FirstOrDefault(e => e.Key == textToProcess);

                if (entry == null || !string.Equals(entry.Key, entry.Value, StringComparison.Ordinal))
                {
                    await _logService.LogAsync($"跳过翻译（文本已被翻译或不存在）: {textToProcess}", LogLevel.Info);
                    return;
                }

                await _logService.LogAsync($"正在翻译: {textToProcess}", LogLevel.Info);

                string translated = await _translationService.TranslateTextAsync(textToProcess, config);

                // 检查取消请求
                if (_cancellationTokenSource?.IsCancellationRequested == true)
                {
                    await _logService.LogAsync($"翻译已取消: {textToProcess}", LogLevel.Info);
                    lock (_processedTexts)
                    {
                        _processedTexts.Remove(textToProcess);
                    }
                    return;
                }

                // 防御性空检查
                if (_parser == null || _monitoredFilePath == null)
                {
                    await _logService.LogAsync($"翻译完成但监控已停止，跳过保存: {textToProcess}", LogLevel.Warning);
                    return;
                }

                // 如果翻译结果和原文一致，跳过保存
                if (string.Equals(textToProcess, translated, StringComparison.Ordinal))
                {
                    await _logService.LogAsync($"跳过翻译（原文和译文相同）: {textToProcess}", LogLevel.Info);
                    return;
                }

                // 更新翻译
                _parser.UpdateTranslation(textToProcess, translated);

                // 保存文件
                await _parser.SaveFileAsync(_monitoredFilePath);

                await _logService.LogAsync($"翻译完成: {textToProcess} -> {translated}", LogLevel.Info);

                // 通知 UI
                EntryTranslated?.Invoke(this, new TranslationEntry
                {
                    Key = textToProcess,
                    Value = translated,
                    IsTranslated = true
                });
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"翻译失败: {textToProcess} - {ex.Message}", LogLevel.Error);

                // 翻译失败时从已处理集合中移除，允许重试
                lock (_processedTexts)
                {
                    _processedTexts.Remove(textToProcess);
                }
            }
        }

        /// <summary>
        /// 通知状态变化
        /// </summary>
        private void NotifyStatusChanged(string status, bool isMonitoring)
        {
            StatusChanged?.Invoke(this, new FileMonitorEventArgs
            {
                Status = status,
                IsMonitoring = isMonitoring,
                FilePath = _monitoredFilePath
            });
        }

        /// <summary>
        /// 获取当前统计信息
        /// </summary>
        public FileStatistics? GetStatistics()
        {
            return _parser?.GetStatistics();
        }

        /// <summary>
        /// 获取待处理文本数量
        /// </summary>
        public int GetPendingCount()
        {
            lock (_pendingTexts)
            {
                return _pendingTexts.Count;
            }
        }

        public void Dispose()
        {
            _ = StopMonitoringAsync();
        }
    }

    /// <summary>
    /// 文件监控事件参数
    /// </summary>
    public class FileMonitorEventArgs : EventArgs
    {
        public string Status { get; set; } = "";
        public bool IsMonitoring { get; set; }
        public string? FilePath { get; set; }
    }
}

