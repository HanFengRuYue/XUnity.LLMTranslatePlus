using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Channels;
using System.Threading.Tasks;
using XUnity_LLMTranslatePlus.Models;
using XUnity_LLMTranslatePlus.Utils;

namespace XUnity_LLMTranslatePlus.Services
{
    /// <summary>
    /// 文件监控服务
    /// </summary>
    public class FileMonitorService : IDisposable
    {
        private readonly TranslationService _translationService;
        private readonly LogService _logService;
        private readonly ConfigService _configService;

        private FileSystemWatcher? _fileWatcher;
        private TextFileParser? _parser;
        private string? _monitoredFilePath;
        private bool _isMonitoring;
        private readonly object _lockObject = new object();

        // 待处理的文本Channel（替代Queue以支持高性能持续并发）
        private Channel<string>? _pendingTexts;

        // 已处理的文本集合（防止重复翻译）
        private readonly HashSet<string> _processedTexts = new HashSet<string>();

        // 取消标记源（用于优雅停止）
        private CancellationTokenSource? _cancellationTokenSource;

        // 消费者任务列表（持续并发翻译）
        private List<Task>? _consumerTasks;

        public event EventHandler<FileMonitorEventArgs>? StatusChanged;
        public event EventHandler<TranslationEntry>? EntryTranslated;
        public event EventHandler<string>? ErrorThresholdReached;

        public bool IsMonitoring
        {
            get
            {
                lock (_lockObject)
                {
                    return _isMonitoring;
                }
            }
        }

        /// <summary>
        /// 获取当前监控的文件路径
        /// </summary>
        public string? MonitoredFilePath => _monitoredFilePath;

        public FileMonitorService(
            TranslationService translationService,
            LogService logService,
            ConfigService configService)
        {
            _translationService = translationService;
            _logService = logService;
            _configService = configService;
        }

        /// <summary>
        /// 开始监控
        /// </summary>
        public async Task StartMonitoringAsync(string gameDirectory)
        {
            if (IsMonitoring)
            {
                await _logService.LogAsync("监控已经在运行中", LogLevel.Warning);
                return;
            }

            try
            {
                // 验证游戏目录路径
                PathValidator.ValidateDirectoryExists(gameDirectory);
                string validatedGameDir = PathValidator.ValidateAndNormalizePath(gameDirectory);

                // 查找 _AutoGeneratedTranslations.txt 文件
                string? filePath = FindTranslationFile(validatedGameDir);

                if (filePath == null)
                {
                    throw new Exception($"在游戏目录中未找到 _AutoGeneratedTranslations.txt 文件: {validatedGameDir}");
                }

                // 验证翻译文件路径
                PathValidator.ValidateFileExists(filePath);

                await _logService.LogAsync($"找到翻译文件: {filePath}", LogLevel.Info);

                _monitoredFilePath = filePath;
                _parser = new TextFileParser();

                // 初始加载文件
                await LoadAndProcessFileAsync();

                // 设置文件监控
                string? directory = Path.GetDirectoryName(filePath);
                if (directory != null)
                {
                    _fileWatcher = new FileSystemWatcher(directory)
                    {
                        Filter = Path.GetFileName(filePath),
                        NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.Size,
                        EnableRaisingEvents = true
                    };

                    _fileWatcher.Changed += OnFileChanged;
                }

                // 初始化取消标记
                _cancellationTokenSource = new CancellationTokenSource();

                // 初始化Channel（无界通道，支持高吞吐量）
                _pendingTexts = Channel.CreateUnbounded<string>(new UnboundedChannelOptions
                {
                    SingleReader = false,  // 多个消费者
                    SingleWriter = false   // 可能有多个生产者（文件监控、初始加载）
                });

                // 清空已处理文本集合
                lock (_processedTexts)
                {
                    _processedTexts.Clear();
                }

                lock (_lockObject)
                {
                    _isMonitoring = true;
                }

                // 启动消费者任务池（持续并发翻译）
                StartConsumerTasks(_configService.GetCurrentConfig());

                await _logService.LogAsync("文件监控已启动", LogLevel.Info);
                NotifyStatusChanged("运行中", true);
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"启动监控失败: {ex.Message}", LogLevel.Error);
                throw;
            }
        }

        /// <summary>
        /// 停止监控
        /// </summary>
        public async Task StopMonitoringAsync()
        {
            if (!IsMonitoring)
            {
                return;
            }

            lock (_lockObject)
            {
                _isMonitoring = false;
            }

            // 取消所有正在进行的操作
            _cancellationTokenSource?.Cancel();

            // 停止Channel写入
            _pendingTexts?.Writer.Complete();

            // 等待所有消费者任务完成（最多等待5秒）
            if (_consumerTasks != null && _consumerTasks.Count > 0)
            {
                try
                {
                    await Task.WhenAll(_consumerTasks).WaitAsync(TimeSpan.FromSeconds(5));
                }
                catch (OperationCanceledException)
                {
                    // 正常取消，忽略
                }
                catch (TimeoutException)
                {
                    await _logService.LogAsync("等待消费者任务完成超时", LogLevel.Warning);
                }
                _consumerTasks.Clear();
                _consumerTasks = null;
            }

            // 停止文件监控
            if (_fileWatcher != null)
            {
                _fileWatcher.EnableRaisingEvents = false;
                _fileWatcher.Changed -= OnFileChanged;
                _fileWatcher.Dispose();
                _fileWatcher = null;
            }

            // 清空Channel和已处理集合
            _pendingTexts = null;

            lock (_processedTexts)
            {
                _processedTexts.Clear();
            }

            // 释放取消标记源
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;

            _parser?.Clear();
            _parser = null;
            _monitoredFilePath = null;

            await _logService.LogAsync("文件监控已停止", LogLevel.Info);
            NotifyStatusChanged("已停止", false);
        }

        /// <summary>
        /// 查找翻译文件
        /// </summary>
        private string? FindTranslationFile(string gameDirectory)
        {
            string bepInExPath = Path.Combine(gameDirectory, "BepInEx", "Translation");

            if (!Directory.Exists(bepInExPath))
            {
                return null;
            }

            // 遍历所有语言文件夹
            var langFolders = Directory.GetDirectories(bepInExPath);

            foreach (var langFolder in langFolders)
            {
                string textFolder = Path.Combine(langFolder, "Text");
                if (Directory.Exists(textFolder))
                {
                    string translationFile = Path.Combine(textFolder, "_AutoGeneratedTranslations.txt");
                    if (File.Exists(translationFile))
                    {
                        return translationFile;
                    }
                }
            }

            return null;
        }

        /// <summary>
        /// 文件变化事件处理
        /// </summary>
        private void OnFileChanged(object sender, FileSystemEventArgs e)
        {
            _ = Task.Run(async () =>
            {
                try
                {
                    await Task.Delay(500); // 等待文件写入完成
                    await LoadAndProcessFileAsync();
                }
                catch (Exception ex)
                {
                    await _logService.LogAsync($"处理文件变化失败: {ex.Message}", LogLevel.Error);
                }
            });
        }

        /// <summary>
        /// 加载并处理文件
        /// </summary>
        private async Task LoadAndProcessFileAsync()
        {
            if (_parser == null || _monitoredFilePath == null)
            {
                return;
            }

            try
            {
                var entries = await _parser.ParseFileAsync(_monitoredFilePath);
                var untranslated = _parser.GetUntranslatedEntries(entries);

                if (untranslated.Count > 0)
                {
                    await _logService.LogAsync($"发现 {untranslated.Count} 条未翻译文本", LogLevel.Info);

                    // 添加到待处理Channel（检查是否已处理）
                    int addedCount = 0;
                    int removedFromCacheCount = 0;
                    var removedPreviews = new List<string>();

                    foreach (var entry in untranslated)
                    {
                        // 如果是未翻译的，从已处理集合中移除（允许重新翻译）
                        bool wasInCache = false;
                        bool shouldAdd = false;

                        lock (_processedTexts)
                        {
                            if (_processedTexts.Contains(entry.Key))
                            {
                                _processedTexts.Remove(entry.Key);
                                removedFromCacheCount++;
                                wasInCache = true;
                            }

                            // 检查是否应该添加（未在已处理集合中）
                            if (!_processedTexts.Contains(entry.Key))
                            {
                                shouldAdd = true;
                            }
                        }

                        if (wasInCache)
                        {
                            string preview = entry.Key.Length > 50
                                ? entry.Key.AsSpan(0, 50).ToString() + "..."
                                : entry.Key;
                            removedPreviews.Add(preview);
                        }

                        // 添加到Channel（非阻塞）
                        if (shouldAdd && _pendingTexts != null)
                        {
                            if (_pendingTexts.Writer.TryWrite(entry.Key))
                            {
                                addedCount++;
                            }
                        }
                    }

                    // 记录所有从缓存中移除的文本
                    foreach (var preview in removedPreviews)
                    {
                        await _logService.LogAsync($"[重新翻译] 从缓存中移除: {preview}", LogLevel.Info);
                    }

                    if (addedCount > 0)
                    {
                        await _logService.LogAsync($"新增 {addedCount} 条待翻译文本到队列", LogLevel.Info);
                    }

                    if (removedFromCacheCount > 0)
                    {
                        await _logService.LogAsync($"从缓存中移除 {removedFromCacheCount} 条需要重新翻译的文本", LogLevel.Info);
                    }
                }
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"加载文件失败: {ex.Message}", LogLevel.Error);
            }
        }

        /// <summary>
        /// 启动消费者任务池（持续并发翻译）
        /// </summary>
        private void StartConsumerTasks(AppConfig config)
        {
            _consumerTasks = new List<Task>();

            // 创建固定数量的消费者任务
            int consumerCount = config.MaxConcurrentTranslations;
            for (int i = 0; i < consumerCount; i++)
            {
                int consumerId = i + 1;
                var task = Task.Run(async () => await ConsumerTaskAsync(consumerId));
                _consumerTasks.Add(task);
            }

            _logService.Log($"已启动 {consumerCount} 个并发翻译任务", LogLevel.Info);
        }

        /// <summary>
        /// 消费者任务（持续从Channel读取并翻译）
        /// </summary>
        private async Task ConsumerTaskAsync(int consumerId)
        {
            if (_pendingTexts == null || _cancellationTokenSource == null)
            {
                return;
            }

            var cancellationToken = _cancellationTokenSource.Token;

            await _logService.LogAsync($"[消费者{consumerId}] 已启动", LogLevel.Debug);

            try
            {
                // 持续从Channel读取直到取消或Channel关闭
                await foreach (var text in _pendingTexts.Reader.ReadAllAsync(cancellationToken))
                {
                    // 检查是否已停止监控
                    if (!IsMonitoring || _parser == null || _monitoredFilePath == null)
                    {
                        break;
                    }

                    // 检查错误阈值
                    var config = _configService.GetCurrentConfig();
                    if (_translationService.TotalFailed >= config.ErrorThreshold)
                    {
                        await _logService.LogAsync($"错误数量已达到阈值 ({config.ErrorThreshold})，停止监控", LogLevel.Error);
                        ErrorThresholdReached?.Invoke(this, $"翻译错误过多（{_translationService.TotalFailed}次），已自动停止监控。请检查API配置和网络连接。");
                        _ = StopMonitoringAsync();
                        break;
                    }

                    // 检查是否已处理
                    bool shouldProcess = false;
                    lock (_processedTexts)
                    {
                        if (!_processedTexts.Contains(text))
                        {
                            _processedTexts.Add(text);
                            shouldProcess = true;
                        }
                    }

                    if (!shouldProcess)
                    {
                        await _logService.LogAsync($"[消费者{consumerId}] 跳过已处理文本", LogLevel.Debug);
                        continue;
                    }

                    try
                    {
                        // 验证文本是否仍需翻译
                        var currentEntries = await _parser.ParseFileAsync(_monitoredFilePath);
                        var entry = currentEntries.FirstOrDefault(e => e.Key == text);

                        if (entry == null || entry.IsTranslated)
                        {
                            await _logService.LogAsync($"[消费者{consumerId}] 跳过已翻译文本", LogLevel.Debug);
                            continue;
                        }

                        // 调试日志
                        string preview = text.Length > 50 ? text.AsSpan(0, 50).ToString() + "..." : text;
                        if (text.Contains("\\n") || text.Contains("\\r") || text.Contains("\\t"))
                        {
                            await _logService.LogAsync($"[消费者{consumerId}][待翻译-含转义] {preview}", LogLevel.Info);
                        }

                        await _logService.LogAsync($"[消费者{consumerId}] 正在翻译: {preview}", LogLevel.Info);

                        // 执行翻译
                        string translated = await _translationService.TranslateTextAsync(text, config, cancellationToken);

                        // 再次检查状态（翻译可能耗时较长）
                        if (!IsMonitoring || _parser == null || _monitoredFilePath == null)
                        {
                            break;
                        }

                        // 如果翻译结果和原文一致，跳过保存
                        if (string.Equals(text, translated, StringComparison.Ordinal))
                        {
                            await _logService.LogAsync($"[消费者{consumerId}] 跳过（原文和译文相同）", LogLevel.Info);
                            continue;
                        }

                        // 更新翻译并保存
                        _parser.UpdateTranslation(text, translated);
                        await _parser.SaveFileAsync(_monitoredFilePath);

                        await _logService.LogAsync($"[消费者{consumerId}] 翻译完成: {preview} -> {translated}", LogLevel.Info);

                        // 通知 UI
                        EntryTranslated?.Invoke(this, new TranslationEntry
                        {
                            Key = text,
                            Value = translated,
                            IsTranslated = true
                        });
                    }
                    catch (OperationCanceledException)
                    {
                        // 取消操作，退出循环
                        break;
                    }
                    catch (Exception ex)
                    {
                        await _logService.LogAsync($"[消费者{consumerId}] 翻译失败: {ex.Message}", LogLevel.Error);

                        // 翻译失败时从已处理集合中移除，允许重试
                        lock (_processedTexts)
                        {
                            _processedTexts.Remove(text);
                        }
                    }
                }
            }
            catch (OperationCanceledException)
            {
                // 正常取消，忽略
            }
            catch (Exception ex)
            {
                await _logService.LogAsync($"[消费者{consumerId}] 异常退出: {ex.Message}", LogLevel.Error);
            }

            await _logService.LogAsync($"[消费者{consumerId}] 已停止", LogLevel.Debug);
        }

        /// <summary>
        /// 通知状态变化
        /// </summary>
        private void NotifyStatusChanged(string status, bool isMonitoring)
        {
            StatusChanged?.Invoke(this, new FileMonitorEventArgs
            {
                Status = status,
                IsMonitoring = isMonitoring,
                FilePath = _monitoredFilePath
            });
        }

        /// <summary>
        /// 获取当前统计信息
        /// </summary>
        public FileStatistics? GetStatistics()
        {
            return _parser?.GetStatistics();
        }

        /// <summary>
        /// 获取待处理文本数量
        /// </summary>
        public int GetPendingCount()
        {
            // Channel不直接提供Count，返回Reader中可用的近似数量
            // 注意：这是一个估算值，实际数量可能略有不同
            return _pendingTexts?.Reader.CanCount == true
                ? _pendingTexts.Reader.Count
                : 0;
        }

        public void Dispose()
        {
            _ = StopMonitoringAsync();
        }
    }

    /// <summary>
    /// 文件监控事件参数
    /// </summary>
    public class FileMonitorEventArgs : EventArgs
    {
        public string Status { get; set; } = "";
        public bool IsMonitoring { get; set; }
        public string? FilePath { get; set; }
    }
}

